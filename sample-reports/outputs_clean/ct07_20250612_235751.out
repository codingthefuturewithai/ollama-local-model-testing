To refactor the given application into a clearer module/package layout, add pytest scaffolding for each module, and explain the changes, follow these steps:
### Step 1: Refactor into a Clearer Module/Package Layout
We will organize the code into separate packages and modules to improve structure and maintainability.
**Directory Structure:**
```
test-data/
└── complex-app/
├── main.py
├── app/
│   ├── __init__.py
│   ├── logic.py
│   └── utils.py
└── tests/
├── test_main.py
├── test_logic.py
└── test_utils.py
```
**main.py:**
```python
# filepath: test-data/complex-app/main.py
import argparse
import sys
from app.logic import TaskManager
from app.utils import DATA_FILE
def main():
parser = argparse.ArgumentParser(description="Simple Command-Line Task Manager")
parser.add_argument("command", choices=["add", "list", "done", "pending"], help="Command to execute")
parser.add_argument("argument", nargs="?", help="Argument for the command (e.g., task description or ID)")
args = parser.parse_args()
task_manager = TaskManager(DATA_FILE)
if args.command == "add":
if not args.argument:
print("Error: Task description cannot be empty for 'add' command.", file=sys.stderr)
sys.exit(1)
task = task_manager.add_task(args.argument)
print(f"Added task: '{task.description}' with ID {task.id}")
elif args.command == "list":
print("Current Tasks:")
tasks = task_manager.list_tasks()
if not tasks:
print("No tasks yet.")
else:
for task in tasks:
status_char = "[x]" if task.status == "completed" else "[ ]"
print(f"{status_char} {task.id}: {task.description}")
elif args.command == "done":
if not args.argument:
print("Error: Task ID required for 'done' command.", file=sys.stderr)
sys.exit(1)
try:
task_id_arg = args.argument
# Attempt to convert to int if it looks like an int, otherwise treat as string (for UUIDs)
try:
task_id = int(task_id_arg)
except ValueError:
task_id = task_id_arg
updated_task = task_manager.complete_task(task_id)
if updated_task:
print(f"Task {updated_task.id} marked as completed.")
else:
print(f"Error: Task with ID {task_id} not found.", file=sys.stderr)
except ValueError: # This might be redundant if previous try-except for int conversion is robust
print(f"Error: Invalid Task ID '{args.argument}'.", file=sys.stderr)
sys.exit(1)
elif args.command == "pending":
print("Pending Tasks:")
tasks = task_manager.list_tasks(status_filter="pending")
if not tasks:
print("No pending tasks.")
else:
for task in tasks:
print(f"[ ] {task.id}: {task.description}")
if __name__ == "__main__":
main()
```
**app/logic.py:**
```python
# filepath: test-data/complex-app/app/logic.py
import uuid
from datetime import datetime
from app.utils import DATA_FILE
class Task:
def __init__(self, description, task_id=None, status="pending", created_at=None, completed_at=None):
self.id = task_id if task_id is not None else str(uuid.uuid4())[:8]
self.description = description
self.status = status
self.created_at = created_at if created_at else datetime.now().isoformat()
self.completed_at = completed_at
def complete(self):
self.status = "completed"
self.completed_at = datetime.now().isoformat()
def to_dict(self):
return {
"id": self.id,
"description": self.description,
"status": self.status,
"created_at": self.created_at,
"completed_at": self.completed_at
}
@classmethod
def from_dict(cls, data):
return cls(
description=data["description"],
task_id=data["id"],
status=data["status"],
created_at=data.get("created_at"),
completed_at=data.get("completed_at")
)
class TaskManager:
def __init__(self, data_file=DATA_FILE):
self.data_file = data_file
self.tasks = self._load_all_tasks()
def _load_all_tasks(self):
raw_tasks = load_tasks_from_json(self.data_file)
return [Task.from_dict(t) for t in raw_tasks]
def _save_all_tasks(self):
utils.save_tasks_to_json([task.to_dict() for task in self.tasks], self.data_file)
def add_task(self, description):
if not description or not isinstance(description, str):
raise ValueError("Task description must be a non-empty string")
new_task = Task(description)
self.tasks.append(new_task)
self._save_all_tasks()
return new_task
def complete_task(self, task_id):
for task in self.tasks:
if str(task.id) == str(task_id):
if task.status == "pending":
task.complete()
self._save_all_tasks()
return task
return None
def list_tasks(self, status_filter=None):
if status_filter:
if status_filter not in ["pending", "completed"]:
raise ValueError("status_filter must be 'pending' or 'completed'")
return [task for task in self.tasks if task.status == status_filter]
return self.tasks
```
**app/utils.py:**
```python
# filepath: test-data/complex-app/app/utils.py
import json
import os
DATA_FILE = "tasks.json"
def load_tasks_from_json(filepath=DATA_FILE):
if not os.path.exists(filepath):
return []
try:
with open(filepath, 'r') as f:
content = f.read()
if not content:
return []
data = json.loads(content)
return data
except (IOError, json.JSONDecodeError) as e:
print(f"Error loading tasks from {filepath}: {e}", file=sys.stderr)
return []
def save_tasks_to_json(tasks_data, filepath=DATA_FILE):
try:
with open(filepath, 'w') as f:
json.dump(tasks_data, f, indent=4)
except IOError as e:
print(f"Error saving tasks to {filepath}: {e}", file=sys.stderr)
```
### Step 2: Add Pytest Scaffolding for Each Module
**tests/test_main.py:**
```python
# filepath: test-data/complex-app/tests/test_main.py
import pytest
from unittest.mock import patch, MagicMock
from app.main import main
from app.logic import TaskManager, Task
from app.utils import DATA_FILE
def mock_task_manager():
task_manager = MagicMock()
task_manager.add_task.return_value = Task("Test Task")
task_manager.complete_task.return_value = Task("Test Task", status="completed")
task_manager.list_tasks.return_value = [Task("Test Task")]
return task_manager
@patch('app.main.TaskManager', new_callable=mock_task_manager)
def test_main_add_task(mock_task_manager):
with patch('sys.argv', ['main.py', 'add', 'Test Task']):
main()
mock_task_manager.add_task.assert_called_once_with('Test Task')
@patch('app.main.TaskManager', new_callable=mock_task_manager)
def test_main_complete_task(mock_task_manager):
with patch('sys.argv', ['main.py', 'done', '12345678']):
main()
mock_task_manager.complete_task.assert_called_once_with('12345678')
@patch('app.main.TaskManager', new_callable=mock_task_manager)
def test_main_list_tasks(mock_task_manager):
with patch('sys.argv', ['main.py', 'list']):
main()
mock_task_manager.list_tasks.assert_called_once_with()
```
**tests/test_logic.py:**
```python
# filepath: test-data/complex-app/tests/test_logic.py
import pytest
from app.logic import Task, TaskManager
def test_task_creation():
task = Task("Test Task")
assert task.id is not None
assert task.description == "Test Task"
assert task.status == "pending"
def test_task_completion():
task = Task("Test Task")
task.complete()
assert task.status == "completed"
assert task.completed_at is not None
def test_task_manager_add_task():
manager = TaskManager()
new_task = manager.add_task("New Task")
assert new_task is not None
assert new_task.description == "New Task"
def test_task_manager_complete_task():
manager = TaskManager()
manager.tasks.append(Task("Test Task"))
updated_task = manager.complete_task("12345678")
assert updated_task is not None
assert updated_task.status == "completed"
```
**tests/test_utils.py:**
```python
# filepath: test-data/complex-app/tests/test_utils.py
import pytest
from app.utils import load_tasks_from_json, save_tasks_to_json
def test_load_tasks_from_json():
data = [
{"id": "1", "description": "Task 1", "status": "pending"},
{"id": "2", "description": "Task 2", "status": "completed"}
]
with open("tasks_test.json", 'w') as f:
json.dump(data, f)
tasks = load_tasks_from_json("tasks_test.json")
assert len(tasks) == 2
assert tasks[0]["id"] == "1"
assert tasks[1]["status"] == "completed"
def test_save_tasks_to_json():
data = [
{"id": "3", "description": "Task 3", "status": "pending"},
{"id": "4", "description": "Task 4", "status": "completed"}
]
save_tasks_to_json(data, "tasks_test.json")
with open("tasks_test.json", 'r') as f:
tasks = json.load(f)
assert len(tasks) == 2
assert tasks[0]["id"] == "3"
assert tasks[1]["status"] == "completed"
```
### Summary
By organizing the code into a package structure and adding pytest tests, you improve the maintainability, readability, and test coverage of your project. This setup also makes it easier to extend or modify the components in the future.
