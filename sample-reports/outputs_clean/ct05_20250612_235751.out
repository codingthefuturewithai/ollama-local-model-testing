## Fibonacci Function API Documentation
### Overview
This is a Python function that calculates Fibonacci numbers up to a given number `n`.
### Function: fibonacci(n)
#### Parameters
- **n (int):** The upper limit for calculating Fibonacci numbers.
#### Return Value
- **List[int]:** A list of Fibonacci numbers from 0 up to but not including the nth number.
#### Examples
1. **Example 1:** Calculate Fibonacci numbers up to 5
```python
result = fibonacci(5)
print(result)  # Output: [0, 1, 1, 2, 3]
```
2. **Example 2:** Calculate Fibonacci numbers up to 0
```python
result = fibonacci(0)
print(result)  # Output: []
```
### Type Hints
```python
def fibonacci(n: int) -> List[int]:
```
### Usage Examples
1. **Basic Usage**
```python
from my_module import fibonacci
fib_sequence = fibonacci(8)
print(fib_sequence)  # Output: [0, 1, 1, 2, 3, 5, 8]
```
2. **Handling Edge Cases**
```python
empty_sequence = fibonacci(0)
print(empty_sequence)  # Output: []
```
### Time Complexity
The time complexity of this function is **O(n)**, as it iterates through the range from 2 to `n` once.
### Space Complexity
The space complexity of this function is also **O(n)**, due to the storage required for the list that holds the Fibonacci numbers up to `n`.
### Potential Improvements and Alternative Approaches
1. **Iterative Approach (Same as Current):** This method is efficient and straightforward, making it suitable for most use cases.
2. **Memoization:** If you need to calculate multiple sequences of Fibonacci numbers, consider using memoization to avoid redundant calculations.
```python
def fibonacci_memo(n: int, memo: Dict[int, int] = {}) -> List[int]:
if n <= 0:
return []
elif n == 1:
return [0]
elif n in memo:
return memo[n]
fib = [0, 1] + [0] * (n - 2)
for i in range(2, n):
fib[i] = fib[i-1] + fib[i-2]
memo[n] = fib
return fib
# Example usage:
result = fibonacci_memo(10)
print(result)  # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```
3. **Matrix Exponentiation:** For very large values of `n`, using matrix exponentiation can be more efficient (O(log n)), though it's more complex to implement.
```python
def fibonacci_matrix_expo(n: int) -> List[int]:
if n <= 0:
return []
elif n == 1:
return [0]
elif n == 2:
return [0, 1]
def multiply(a: List[List[int]], b: List[List[int]]) -> List[List[int]]:
result = [[0, 0], [0, 0]]
for i in range(2):
for j in range(2):
for k in range(2):
result[i][j] += a[i][k] * b[k][j]
return result
def matrix_power(matrix: List[List[int]], power: int) -> List[List[int]]:
result = [[1, 0], [0, 1]]  # Identity matrix
while power > 0:
if power % 2 == 1:
result = multiply(result, matrix)
matrix = multiply(matrix, matrix)
power //= 2
return result
F = [[1, 1], [1, 0]]
F_matrix = matrix_power(F, n - 1)
fib = [0] * (n + 1)
fib[0], fib[1] = 0, 1
for i in range(2, n + 1):
fib[i] = F_matrix[0][0]
return fib
# Example usage:
result = fibonacci_matrix_expo(10)
print(result)  # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```
These alternatives provide different approaches to the Fibonacci sequence calculation and can be selected based on specific requirements or performance considerations.
